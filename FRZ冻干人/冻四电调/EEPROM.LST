C51 COMPILER V9.00   EEPROM                                                                07/26/2017 18:44:54 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE EEPROM
OBJECT MODULE PLACED IN EEPROM.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE EEPROM.c LARGE BROWSE DEBUG OBJECTEXTEND

line level    source

   1          
   2          //2017-02-14
   3          
   4          #include "reg51.h"
   5          //#include "UNIQ_ID.h"
   6          #include "EEPROM.h"
   7          #include "intrins.h"
   8          
   9          typedef unsigned char BYTE;
  10          typedef unsigned int WORD;
  11          
  12          sfr  IAP_DATA   = 0xC2;     
  13          sfr  IAP_ADDRH  = 0xC3;     
  14          sfr  IAP_ADDRL  = 0xC4;   
  15          sfr  IAP_CMD    = 0xC5;     
  16          sfr  IAP_TRIG   = 0xC6;      
  17          sfr  IAP_CONTR  = 0xC7;     
  18          
  19          #define   CMD_IDLE      0   
  20          #define   CMD_READ      1    
  21          #define   CMD_WRITE     2    
  22          #define   CMD_ERASE     3  
  23          
  24          //IAP????
  25          //#define   ENABLE_IAP   0x80    //??????<30MHz
  26          #define   ENABLE_IAP   0x81    //??????<24MHz
  27          //#define   ENABLE_IAP   0x82    //??????<20MHz
  28          //#define   ENABLE_IAP   0x83    //??????<12MHz
  29          //#define   ENABLE_IAP   0x84    //??????<6MHz
  30          //#define   ENABLE_IAP   0x85    //??????<3MHz
  31          //#define   ENABLE_IAP   0x86    //??????<2MHz
  32          //#define   ENABLE_IAP   0x87    //??????<1MHz
  33          
  34          
  35          //#define    IAP_ADDRE   0x0000
  36          
  37          
  38          
  39          /*
  40          例子：
  41          #define    IAP_ADDRE   0x0000
  42          #define    IAP_ADDRE   0x0000
  43          
  44                  IapEraseSector(IAP_ADDRE);
  45                  for(i = 0; i < 3*4; i++)
  46                  {
  47                          IapWriteByte( IAP_ADDRE + i, ip0[i] );
  48                  }
  49                  for(i = 0; i < 3*4; i++)
  50                  {
  51                          ip0[i] = IapReadByte( IAP_ADDRE + i );
  52                  }
  53                  //j = IapReadByte( IAP_ADDRE );
  54                  //j++;
  55                  //IapEraseSector(IAP_ADDRE);
C51 COMPILER V9.00   EEPROM                                                                07/26/2017 18:44:54 PAGE 2   

  56                  //IapWriteByte( IAP_ADDRE , j );
  57                  */
  58                  
  59          
  60          
  61          #if 0
              
              
              void eeprom_read_block( unsigned int addr, unsigned char *p, unsigned int len )
              {
                      unsigned int eeprom_block_count_i;
                      for( eeprom_block_count_i = 0; eeprom_block_count_i < len; eeprom_block_count_i++ )
                      {
                              p[eeprom_block_count_i] = IapReadByte( addr + eeprom_block_count_i );
                      }
              }
              
              
              void eeprom_write_block( unsigned int addr, unsigned char *p, unsigned int len ) // 需要辅以 IapEraseSecto
             -r        
              {
                      unsigned int eeprom_block_count_i;
                      for( eeprom_block_count_i = 0; eeprom_block_count_i < len; eeprom_block_count_i++ )
                      {
                              IapWriteByte( addr + eeprom_block_count_i, p[eeprom_block_count_i] );
                      }
              }
              
              unsigned char eeprom_check_diff_block( unsigned int addr, unsigned char *p, unsigned int len )
              {
                      unsigned int eeprom_block_count_i;
                      for( eeprom_block_count_i = 0; eeprom_block_count_i < len; eeprom_block_count_i++ )
                      {
                              if( p[eeprom_block_count_i] != IapReadByte( addr + eeprom_block_count_i ) )
                              {
                                      return 1;
                              }
                      }
                      return 0;
              }
              
              #endif
  97          
  98          
  99          
 100          
 101          
 102          
 103          
 104          
 105          
 106          
 107          
 108          
 109          #if 0
              
              
              
              /**********************************************************
              ** ????: void IapIdle();
              ** ????: ??IAP??
              **********************************************************/
C51 COMPILER V9.00   EEPROM                                                                07/26/2017 18:44:54 PAGE 3   

              //void IapIdle()
              //{
              //    IAP_CONTR = 0;       //?? IAP ??
              //    IAP_CMD   = 0;       //?????????????
              //    IAP_TRIG  = 0;       //???????
              //    IAP_ADDRH = 0xFF;    //IAP?????? EEPROM ??
              //    IAP_ADDRL = 0xFF;
              //}
              
              /*----------------------------
              关闭IAP
              ----------------------------*/
              void IapIdle()
              {
                  IAP_CONTR = 0;                  //关闭IAP功能
                  IAP_CMD = 0;                    //清除命令寄存器
                  IAP_TRIG = 0;                   //清除触发寄存器
                  IAP_ADDRH = 0x80;               //将地址设置到非IAP区域
                  IAP_ADDRL = 0;
              }
              
              
              
              
              /**********************************************************
              ** ????: unsigned char IapReadByte(unsigned int addr);
              ** ????: ?EEPROM
              ** ?   ?: unsigned int addr  ??
              ** ?   ?: unsigned char dat  ??
              **********************************************************/
              unsigned char IapReadByte(unsigned int addr)
              {
                  unsigned char dat;        //????
                  IAP_CONTR = ENABLE_IAP;   //?? IAP ??, ???????
                  IAP_CMD   = CMD_READ;     //?? ISP/IAP/EEPROM ????
                  IAP_ADDRL = addr;         //?? ISP/IAP/EEPROM ????
                  IAP_ADDRH = addr >> 8;    //?? ISP/IAP/EEPROM ????
                  IAP_TRIG  = 0x5a;         //?????? 1 (0x5a)
                  IAP_TRIG  = 0xa5;         //?????? 2 (0xa5)
                  _nop_();                  //MCU ???? ISP/IAP/EEPROM ????
                  _nop_();                  //??15F104E??bug,NOP3?
                  _nop_();                  //
                  dat = IAP_DATA;           //?? ISP/IAP/EEPROM ??
                  IapIdle();                //?? ISP/IAP/EEPROM ??
                  return dat;               //?? Flash ??
              }
              
              
              
              /**********************************************************
              ** ????: void IapWriteByte(unsigned int addr, unsigned char dat);
              ** ????: ?EEPROM??
              ** ?   ?: unsigned int addr  ???
                           unsigned char dat  ???
              **********************************************************/
              void IapWriteByte(unsigned int addr, unsigned char dat)
              {
                  IAP_CONTR = ENABLE_IAP;    //?? IAP ??, ???????
                  IAP_CMD   = CMD_WRITE;     //?? ISP/IAP/EEPROM ????
                  IAP_ADDRL = addr;          //?? ISP/IAP/EEPROM ????
                  IAP_ADDRH = addr >> 8;     //?? ISP/IAP/EEPROM ????
                  IAP_DATA  = dat;           //? ISP/IAP/EEPROM ??
C51 COMPILER V9.00   EEPROM                                                                07/26/2017 18:44:54 PAGE 4   

                  IAP_TRIG  = 0x5a;          //?????? 1 (0x5a)
                  IAP_TRIG  = 0xa5;          //?????? 2 (0xa5)
                  _nop_();                   //MCU ???? ISP/IAP/EEPROM ????
                  _nop_();                   //??15F104E??bug,NOP3?
                  _nop_();                   //
                  IapIdle();                 //?? ISP/IAP/EEPROM ??
              }
              
              
              
              /**********************************************************
              ** ????: void IapEraseSector(unsigned int addr);
              ** ????: ??EEPROM??
              ** ?   ?: unsigned int addr ????
              **********************************************************/
              void IapEraseSector(unsigned int addr)
              {
                  IAP_CONTR = ENABLE_IAP;   //?? IAP ??, ???????
                  IAP_CMD   = CMD_ERASE;    //?? ISP/IAP/EEPROM ?????
                  IAP_ADDRL = addr;         //?? ISP/IAP/EEPROM ????
                  IAP_ADDRH = addr >> 8;    //?? ISP/IAP/EEPROM ????
                  IAP_TRIG  = 0x5a;         //?????? 1 (0x5a)
                  IAP_TRIG  = 0xa5;         //?????? 2 (0xa5)
                  _nop_();                  //MCU ???? ISP/IAP/EEPROM ????
                  _nop_();                  //??15F104E??bug,NOP3?
                  _nop_();                  //
                  IapIdle();                //?? ISP/IAP/EEPROM ??
              }
              
              
              #endif
 210          
 211          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   ----    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
