C51 COMPILER V9.00   A_COMFUNC                                                             07/26/2017 18:44:53 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE A_COMFUNC
OBJECT MODULE PLACED IN a_comfunc.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE a_comfunc.c LARGE BROWSE DEBUG OBJECTEXTEND

line level    source

   1          
   2          // 2016-10-02   
   3          
   4          #include "a_strfunc.h"
   5          #include "UNIQ_ID.h"
   6          
   7          #include "a_comfunc.h"
   8          
   9           
  10          
  11          //=====================================COM1     
  12          
  13          #if 1
  14          unsigned char Com1_TI_flag = 1;
  15          #endif
  16          
  17          
  18          
  19          #if 1
  20          void Com1SendU8( unsigned char c )
  21          {
  22   1              while(!Com1_TI_flag); Com1_TI_flag = 0; 
  23   1              SBUF = c;
  24   1      }
  25          #endif
  26          
  27          
  28          
  29          #if 1
  30          void Com1SendU8ss( unsigned char * s )
  31          {
  32   1              for(;;)
  33   1              {
  34   2                      if( *s == 0 ) break;
  35   2                      Com1SendU8( *s ); 
  36   2                      s++;
  37   2              }
  38   1      }
  39          #endif
  40          
  41          
  42          
  43          #if 0
              void Com1SendU8is( unsigned long i, unsigned char * buf )
              {
                      myltoa( buf, i, 0x00 );
                      Com1SendU8ss( buf );
              }
              #endif
  50          
  51          //
  52          //void send_struct( unsigned char * buf, unsigned char iBufLen )
  53          //{
  54          //      U8 i; 
  55          //      
C51 COMPILER V9.00   A_COMFUNC                                                             07/26/2017 18:44:53 PAGE 2   

  56          //      for( i = 0; i < iBufLen; i++ )
  57          //      {
  58          //              Com1SendU8( buf[i] );
  59          //      }
  60          //}
  61                          //      //send_struct( M2do.m_buf[0], 18 );
  62                          //      //send_struct( M2do.m_buf[1], 18 );
  63          
  64          
  65          
  66          
  67          
  68          // Com1 接收 
  69          #if 0
              
              U8  Com1Recv_rc;
              U8  Com1Recv_c;
              
              U16     Com1Recv_TimeOutLmt = 2345;
              static U16 Com1Recv_TimeOutCounter;
              
              void Com1Recv()
              {
                      Com1Recv_TimeOutCounter = 0;
                      while(1)
                      {
                              if(RI) 
                              { 
                                      RI=0; 
                                      Com1Recv_c = SBUF;
                                      Com1Recv_rc = 1;
                                      return;
                              } 
                              else 
                              { 
                                      Com1Recv_TimeOutCounter++; 
                                      if( Com1Recv_TimeOutCounter > Com1Recv_TimeOutLmt ) 
                                      { 
                                              Com1Recv_rc = 0;
                                              return;
                                      } 
                              } 
                      }
              }
              #endif
 101          
 102          
 103          
 104          
 105          
 106          
 107          
 108          //=====================================COM2     
 109          
 110          
 111          #if 1
 112          unsigned char Com2_TI_flag = 1;
 113          #endif
 114          
 115          
 116          
 117          #if 1
C51 COMPILER V9.00   A_COMFUNC                                                             07/26/2017 18:44:53 PAGE 3   

 118          void Com2SendU8( unsigned char c )
 119          {
 120   1              while(!Com2_TI_flag); Com2_TI_flag = 0; 
 121   1              S2BUF = c;
 122   1      }
 123          #endif
 124          
 125          
 126          
 127          #if 1
 128          void Com2SendU8ss( unsigned char * s )
 129          {
 130   1              for(;;)
 131   1              {
 132   2                      if( *s == 0 ) break;
 133   2                      Com2SendU8( *s ); 
 134   2                      s++;
 135   2              }
 136   1      }
 137          #endif
 138          
 139          
 140          
 141          #if 0
              void Com2SendU8is( unsigned long i, unsigned char * buf )
              {
                      myltoa( buf, i, 0x00 );
                      Com2SendU8ss( buf );
              }
              #endif
 148          
 149          
 150          
 151          
 152          
 153          
 154          
 155          
 156          //===============================程序例子：
 157          #if 0 
              
              /*------------------------------------------------
              串口中断程序
              ------------------------------------------------*/
              void UART_SER() interrupt 4 //串行中断服务程序
              {
                      if(RI)      //判断是接收中断产生
                      {
                              RI=0;     //标志位清零
              
                              ta63com1( &ta63com1_state );
                      }
              
                      if(TI)    //如果是发送标志位，清零
                      {
                              TI=0;
                              Com1_TI_flag = 1; //这样等于发送没做，另找一个flag
                      }
              }
                              
              
              #define S2RI  0x01              //S2CON.0
C51 COMPILER V9.00   A_COMFUNC                                                             07/26/2017 18:44:53 PAGE 4   

              #define S2TI  0x02              //S2CON.1
              
              /*----------------------------
              UART2 中断服务程序
              -----------------------------*/
              void Uart2() interrupt 8  
              {
                  if (S2CON & S2RI)      //判断是接收中断产生
                  {
                      S2CON &= ~S2RI;         //清除S2RI位
                      //P0 = S2BUF;             //P0显示串口数据
                      //P2 = (S2CON & S2RB8);   //P2.2显示校验位
              
                  }
              
                  if (S2CON & S2TI)    //如果是发送标志位，清零
                  {
                      S2CON &= ~S2TI;         //清除S2TI位 
                              Com2_TI_flag = 1; //这样等于发送没做，另找一个flag
                  }
                              
              }
              
              
              
              
              
              
              /*------------------------------------------------
              串口中断程序
              ------------------------------------------------*/
              void UART_SER() interrupt 4 //串行中断服务程序
              {
                      if(RI)      //判断是接收中断产生
                      {
                              RI=0;     //标志位清零
                              
                              ta33com1( &ta33com1_state );
                      }
              
                      if(TI)    //如果是发送标志位，清零
                      {
                              TI=0;
                              Com1_TI_flag = 1; //这样等于发送没做，另找一个flag
                      }
              }
                              
              
              #define S2RI  0x01              //S2CON.0
              #define S2TI  0x02              //S2CON.1
              
              /*----------------------------
              UART2 中断服务程序
              -----------------------------*/
              void Uart2() interrupt 8  
              {
                  if (S2CON & S2RI)      //判断是接收中断产生
                  {
                      S2CON &= ~S2RI;         //清除S2RI位
                      
                              ta32com2( &ta32com2_state );
                  }
C51 COMPILER V9.00   A_COMFUNC                                                             07/26/2017 18:44:53 PAGE 5   

              
                  if (S2CON & S2TI)    //如果是发送标志位，清零
                  {
                      S2CON &= ~S2TI;         //清除S2TI位 
                              Com2_TI_flag = 1; //这样等于发送没做，另找一个flag
                  }
                              
              }
              
              
              
              #endif
 254          
 255          
 256          
 257          
 258          
 259          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =     66    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      2    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
