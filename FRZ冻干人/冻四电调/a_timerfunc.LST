C51 COMPILER V9.00   A_TIMERFUNC                                                           07/27/2017 12:08:32 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE A_TIMERFUNC
OBJECT MODULE PLACED IN a_timerfunc.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE a_timerfunc.c LARGE BROWSE DEBUG OBJECTEXTEND

line level    source

   1          
   2           //     2017-07-26
   3          
   4          //#include "reg52.h"
   5          #include "string.h"
   6          #include "a_strfunc.h"
   7          #include "a_timerfunc.h"
   8          
   9          
  10          //比如stc89c52为0xe7，stc125a60s2为0xc7; 
  11          
  12          sfr IAP_CONTR=0xc7;
  13          
  14          
  15          
  16          #if 1
  17          
  18          
  19          
  20          // e.g.
  21          //struct        TM_t    tm_grind1;
  22          //struct        TM_t    tm_pause1;
  23          //struct        TM_t    tm_dim;
  24          //struct        TM_t    tm_total;
  25          
  26          
  27          
  28          
  29          /* 支持的优先级是：在timer中走tk， 在main中rst
  30                  或在main中走tk和rst     */
  31          
  32          
  33          
  34          //0=在timer中走tk， 在main中rst
  35          //1=在main中走tk和rst
  36          #define TM_PRIORITY_MODE  0
  37          
  38          
  39          
  40          //0=tk频繁，rst不频繁
  41          //1=tk缓慢，rst频繁
  42          #define TM_OFTEN_MODE  0
  43          
  44          
  45          
  46          
  47          
  48          //
  49          void tm_init( struct TM_t *t )
  50          {
  51   1              //t->rst_cmd = 0;
  52   1              //t->rst_value = 0;
  53   1              //t->inter_counter = 0;
  54   1              //t->overflow_flag = 0;
  55   1              //t->pause_cmd = 0;
C51 COMPILER V9.00   A_TIMERFUNC                                                           07/27/2017 12:08:32 PAGE 2   

  56   1              //t->ex_is_busy0 = 0;
  57   1              //t->ex_is_busy1 = 0;
  58   1              //t->ex_is_hot0 = 0;
  59   1              //t->ex_is_hot1 = 0;
  60   1              //t->ex_counter0 = 0;
  61   1              //t->ex_counter1 = 0;
  62   1              //t->ex_counter2 = 0;
  63   1      
  64   1      
  65   1              memset( t, 0, sizeof(struct TM_t) );            
  66   1              
  67   1              t->overflow_flag = 1;
  68   1      }
  69          
  70          
  71          
  72          //每个tk触发一次减1
  73          void tm_tk( struct TM_t *t )
  74          {
  75   1              if( t->rst_cmd ) 
  76   1              {
  77   2                      t->inter_counter = t->rst_value;
  78   2      
  79   2                      t->overflow_flag = 0;
  80   2       
  81   2      
  82   2      #if TM_PRIORITY_MODE == 0  
  83   2                      t->rst_cmd = 0;
  84   2      #else 
               
                      //如果tk频繁则tk中应该--，如果rst频繁则tk中应该直接清0
                      #if TM_OFTEN_MODE == 0
                                      t->rst_cmd --;
                      #else 
                                      t->rst_cmd = 0;
                      #endif
                 
              #endif
  94   2      
  95   2              }
  96   1      
  97   1      
  98   1              do{
  99   2      
 100   2                      if( t->inter_counter == 0 )
 101   2                      {
 102   3                              t->overflow_flag = 1;
 103   3                              break;
 104   3                      }
 105   2      
 106   2                      if( t->pause_cmd ) break;
 107   2      
 108   2                      t->inter_counter --;
 109   2              
 110   2                      if( t->inter_counter == 0 )
 111   2                      {
 112   3                              t->overflow_flag = 1;
 113   3                              break;
 114   3                      }
 115   2      
 116   2              }while(0);
 117   1      
C51 COMPILER V9.00   A_TIMERFUNC                                                           07/27/2017 12:08:32 PAGE 3   

 118   1              if( !t->ex_is_busy0 )
 119   1              {
 120   2                      t->ex_counter0 = t->inter_counter;
 121   2                      t->ex_is_hot0 = 1;
 122   2              }
 123   1      
 124   1              if( !t->ex_is_busy1 )
 125   1              {
 126   2                      t->ex_counter1 = t->inter_counter;
 127   2                      t->ex_is_hot1 = 1;
 128   2              }
 129   1      }
 130          
 131          
 132          
 133          
 134          #if 1
 135          //每次触发可能经过n个tk，要减n
 136          void tm_tk_n( struct TM_t *t, unsigned char t1, unsigned char t2 )
 137          {
 138   1              for( ; t1 != t2 ; t1++ )
 139   1                      tm_tk( t );
 140   1      }
 141          #endif
 142          
 143          
 144          
 145          
 146          #if 0
              //
              void tm_mainfollow( struct TM_t *t )
              {
                      t->ex_is_busy0 = 1;
                      if( t->ex_is_hot0 )
                      {
                              t->ex_counter2 = t->ex_counter0;
                      }
                      t->ex_is_hot0 = 0;
                      t->ex_is_busy0 = 0;
              
                      t->ex_is_busy1 = 1;
                      if( t->ex_is_hot1 )
                      {
                              t->ex_counter2 = t->ex_counter1;
                      }
                      t->ex_is_hot1 = 0;
                      t->ex_is_busy1 = 0;
              }
              #endif
 167          
 168          
 169          
 170          
 171          
 172          
 173          //频繁rst允许，但代价是 不能影响到初始值。      
 174          //如果tk频繁则tk中应该--，如果rst频繁则tk中应该直接清0
 175          void tm_rst( struct TM_t *t, U32 rst_value ) 
 176          {
 177   1              //rst_cmd本身就是一种busy flag可以在外部判断busy_flag，进来时必须已经不busy_flag。或者完全不看busy_flag标
             -记。
 178   1      
C51 COMPILER V9.00   A_TIMERFUNC                                                           07/27/2017 12:08:32 PAGE 4   

 179   1      #if TM_PRIORITY_MODE == 0  
 180   1              if( t->rst_cmd ) return;
 181   1      #else              
                      if( t->rst_cmd > 200 ) return;
              #endif
 184   1      
 185   1              t->rst_value = rst_value;//先有value后有cmd则可防同步问题
 186   1      
 187   1              if( rst_value != 0 ) t->overflow_flag = 0; else t->overflow_flag = 1;
 188   1      
 189   1      
 190   1      #if TM_PRIORITY_MODE == 0  
 191   1                      t->rst_cmd = 1;
 192   1      #else              
                              if( t->rst_cmd < 200 ) t->rst_cmd ++;
              #endif
 195   1      }
 196          
 197          
 198          #endif
 199          
 200          
 201          
 202          
 203          
 204          
 205          
 206          
 207          #if 1
 208          
 209          void tm_rst1( struct TM_t *t, U32 rst_value )
 210          {
 211   1      #if TM_PRIORITY_MODE == 0  
 212   1              if( t->rst_cmd ) return;
 213   1      #else              
                      if( t->rst_cmd > 200 ) return;
              #endif
 216   1      
 217   1              t->rst_value = rst_value;//     
 218   1      
 219   1              if( rst_value != 0 ) t->overflow_flag = 0; else t->overflow_flag = 1;
 220   1      
 221   1      #if TM_PRIORITY_MODE == 0  
 222   1                      t->rst_cmd = 1;
 223   1      #else              
                              if( t->rst_cmd < 200 ) t->rst_cmd ++;
              #endif
 226   1      }
 227          
 228          #endif
 229          
 230          
 231          
 232          
 233          
 234          
 235          #if 0
              
              void tm_rst2( struct TM_t *t, U32 rst_value )
              {
              #if TM_PRIORITY_MODE == 0  
                      if( t->rst_cmd ) return;
C51 COMPILER V9.00   A_TIMERFUNC                                                           07/27/2017 12:08:32 PAGE 5   

              #else              
                      if( t->rst_cmd > 200 ) return;
              #endif
              
                      t->rst_value = rst_value;//     
              
                      if( rst_value != 0 ) t->overflow_flag = 0; else t->overflow_flag = 1;   
              
              #if TM_PRIORITY_MODE == 0  
                              t->rst_cmd = 1;
              #else              
                              if( t->rst_cmd < 200 ) t->rst_cmd ++;
              #endif
              }
              
              #endif
 257          
 258          
 259          
 260          
 261          
 262          
 263          
 264          
 265          
 266          
 267          
 268          //============= tk 类型，统一登记制度   
 269          
 270          #if 0
              
              
              struct TMRTKALL_t
              {
                      struct TM_t             *m_ptm;         
              };
              
              
              static struct TMRTKALL_t  tmrtkall_ws[4];
              static  U8                                tmrtkall_end = 0; //相当于stl中的end，是无效元素                      
              
              
              
              void tmtkall_reg( struct TM_t *t )              //登记和初始化
              {
                      if( tmrtkall_end >= 4 )
                      {
                              IAP_CONTR |= 1<<5; 
              
                              IAP_CONTR = 0x60; /////////////////总量和上面的数组长度一致////
                      }
              
                      tmrtkall_ws[tmrtkall_end].m_ptm = t;
              
                      tm_init( t ); //先初始化再宣布它的存在，不让tk 出问题。
                      //tm_rst( t, 0 );
              
                      tmrtkall_end++; // 再宣布它的存在       
              }
              
              
              void tmtkall_tk()
C51 COMPILER V9.00   A_TIMERFUNC                                                           07/27/2017 12:08:32 PAGE 6   

              {
                      U8 i;
                      for( i = 0; i < tmrtkall_end; i++ )
                      {
                              tm_tk( tmrtkall_ws[i].m_ptm );
                      }
              }
              
              
              void tmtkall_mainfollow()
              {
                      U8 i;
                      for( i = 0; i < tmrtkall_end; i++ )
                      {
                              tm_mainfollow( tmrtkall_ws[i].m_ptm );
                      }
              }
              
              
              
              
              #endif
 325          
 326          
 327          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    586    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      25
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
