C51 COMPILER V9.00   MAIN                                                                  07/26/2017 18:44:54 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c LARGE BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /*******************/
   2          //#include <reg52.h>
   3          #include "STDIO.H"
   4          #include "STDLIB.H"
   5          #include "INTRINS.H"
   6          #include "STRING.H"
   7          #include "Delay_12M.h"
   8          #include "UNIQ_ID.h"
   9          #include "a_strfunc.h"
  10          #include "a_comfunc.h"
  11          #include "a_timerfunc.h"
  12          //#include "lcd_12864.h"
  13          #include "mainioport.h"
  14          #include "EEPROM.h"
  15          #include "stc12_adc.h"
  16          #include "a_ll1func.h"
  17          //#include "ds1302.h"
  18          #include "mpu9250iica.h"
  19          #include "bmp180.h"
  20          //#include "bmp280iica.h"
  21          
  22          
  23          unsigned char idata g_ctrl_timer[2];
  24          unsigned int idata * idata g_p_ctrl_timer;
  25          
  26          
  27          #define    FIRMWAREVER   "V1.00"
  28          
  29          
  30          #define S1_S0 0x40              //P_SW1.6
  31          #define S1_S1 0x80              //P_SW1.7
  32          
  33          #define S2_S0 0x01              //P_SW2.0
  34          
  35          
  36          #include "main1.xpp"
  37          #include "main2.xpp"
  38          
  39          
  40          
  41          
  42          void Timer0Init(void)           //5毫秒@24.000MHz
  43          {
  44   1              AUXR &= 0x7F;           //定时器时钟12T模式
  45   1              TMOD &= 0xF0;           //设置定时器模式
  46   1              TL0 = 0xF0;             //设置定时初值
  47   1              TH0 = 0xD8;             //设置定时初值
  48   1              TF0 = 0;                //清除TF0标志
  49   1              TR0 = 1;                //定时器0开始计时
  50   1      }
  51          
  52          void Timer1Init(void)           //5毫秒@24.000MHz
  53          {
  54   1              AUXR &= 0xBF;           //定时器时钟12T模式
  55   1              TMOD &= 0x0F;           //设置定时器模式
C51 COMPILER V9.00   MAIN                                                                  07/26/2017 18:44:54 PAGE 2   

  56   1              TL1 = 0xF0;             //设置定时初值
  57   1              TH1 = 0xD8;             //设置定时初值
  58   1              TF1 = 0;                //清除TF1标志
  59   1              TR1 = 1;                //定时器1开始计时
  60   1      }
  61          
  62          void Timer3Init(void)           //5毫秒@24.000MHz
  63          {
  64   1              T4T3M &= 0xFD;          //定时器时钟12T模式
  65   1              T3L = 0xF0;             //设置定时初值
  66   1              T3H = 0xD8;             //设置定时初值
  67   1              T4T3M |= 0x08;          //定时器3开始计时
  68   1      }
  69          
  70          void Timer4Init(void)           //5毫秒@24.000MHz
  71          {
  72   1              T4T3M &= 0xDF;          //定时器时钟12T模式
  73   1              T4L = 0xF0;             //设置定时初值
  74   1              T4H = 0xD8;             //设置定时初值
  75   1              T4T3M |= 0x80;          //定时器4开始计时
  76   1      }
  77          
  78          
  79          
  80          // 使用定时器2
  81          void Uart1Init(void)            //9600bps@24.000MHz
  82          {
  83   1              SCON = 0x50;            //8位数据,可变波特率
  84   1              AUXR |= 0x01;           //串口1选择定时器2为波特率发生器
  85   1              AUXR &= 0xFB;           //定时器2时钟为Fosc/12,即12T
  86   1              T2L = 0xCC;             //设定定时初值
  87   1              T2H = 0xFF;             //设定定时初值
  88   1              AUXR |= 0x10;           //启动定时器2
  89   1      }
  90          
  91          void Uart2Init(void)            //9600bps@24.000MHz
  92          {
  93   1              S2CON = 0x50;           //8位数据,可变波特率
  94   1              AUXR &= 0xFB;           //定时器2时钟为Fosc/12,即12T
  95   1              T2L = 0xCC;             //设定定时初值
  96   1              T2H = 0xFF;             //设定定时初值
  97   1              AUXR |= 0x10;           //启动定时器2
  98   1      }
  99          
 100          
 101          char flag2;
 102          
 103          
 104          //
 105          //主函数 入口函数:
 106          void main()
 107          {
 108   1              g_p_ctrl_timer = (unsigned int*)g_ctrl_timer;
 109   1              *g_p_ctrl_timer = 65535L - 59999;
 110   1              
 111   1              //初始化
 112   1              EA=0;           // 总中断
 113   1       
 114   1              Timer0Init();
 115   1              Timer1Init();
 116   1              Timer3Init();
 117   1              Timer4Init();
C51 COMPILER V9.00   MAIN                                                                  07/26/2017 18:44:54 PAGE 3   

 118   1              ET0=1;          //开启定时器0中断
 119   1              ET1 = 1;                        //使能定时器
 120   1              //IE2 |= 0x04;                    //开定时器2中断
 121   1              IE2 |= 0x20;                    //开定时器3中断
 122   1              IE2 |= 0x40;                    //开定时器4中断
 123   1      
 124   1      
 125   1              Uart1Init();
 126   1        //ACC = P_SW1;
 127   1        //ACC &= ~(S1_S0 | S1_S1);    //S1_S0=1 S1_S1=0
 128   1        //ACC |= S1_S0;               //(P3.6/RxD_2, P3.7/TxD_2)
 129   1        //P_SW1 = ACC;  
 130   1              ES = 1;                     //使能串口中断
 131   1      
 132   1              Uart2Init();
 133   1        P_SW2 |= S2_S0;             //S2_S0=1 (P4.6/RxD2_2, P4.7/TxD2_2)
 134   1              IE2 = 0x01;                 //使能串口2中断
 135   1              
 136   1              //切换优先级
 137   1              //PT0 = 0;
 138   1              //PS = 1;
 139   1              //IP2 |= 1;
 140   1      
 141   1      
 142   1              //Com2SendU8ss( "AT+BOUD3" );应该在使能之后再发出。
 143   1              //DelayMs(300);
 144   1      
 145   1      
 146   1              //用户初始化 
 147   1              M1Conf_t_default( &M1 );
 148   1              M5Runtime_t_default( &M5 );
 149   1              M12Pwm_t_default( M12 + 0 );
 150   1              M12Pwm_t_default( M12 + 1 );
 151   1              M12Pwm_t_default( M12 + 2 );
 152   1              M12Pwm_t_default( M12 + 3 );
 153   1              M22ATbuf_t_default( M22 + 0 );
 154   1              M22ATbuf_t_default( M22 + 1 );
 155   1              
 156   1              mainioport_init();
 157   1      
 158   1      
 159   1              Init_MPU9250();
 160   1              Init_BMP085();
 161   1              //Reset_BMP280();
 162   1               
 163   1      
 164   1              tm_init( &ta1comrecv_tm );
 165   1              tm_init( &ta71beeplong_tm );
 166   1      
 167   1      
 168   1              DelayMs(300);
 169   1              EA  = 1;          //打开总中断 
 170   1      
 171   1                
 172   1      
 173   1              //while(EA)
 174   1              {
 175   2                       
 176   2                      DelayMs(333);
 177   2              
 178   2                      //M2Work.m_hi_tta = 900;
 179   2                      //M2Work.m_hi_ttb = 900;
C51 COMPILER V9.00   MAIN                                                                  07/26/2017 18:44:54 PAGE 4   

 180   2                      //M2Work.m_hi_ttc = 900;
 181   2                      //M2Work.m_hi_ttd = 900;
 182   2      
 183   2                      //sharedata_main_ready( &M2[0] , &M2[1] , &M2[2] , sizeof( struct M12Pwm_t ) );
 184   2                      
 185   2                      //Get_BMP280();
 186   2      
 187   2                      //sprintf( printbuf, "%f, %f\r\n", BMP280_Pressure, BMP280_Temperature );
 188   2                                      sprintf( printbuf, "OK. %ld,%ld\r\n",   g_bmp085_pressure, g_bmp085_temperature );
 189   2                      Com1SendU8ss( printbuf );
 190   2      
 191   2                      //if( flag2 )
 192   2                      //{
 193   2                      //      flag2 = 0;
 194   2      
 195   2                      //      for( M2Work.m_hi_tta = 0; M2Work.m_hi_tta < 24; M2Work.m_hi_tta++ )
 196   2                      //      {
 197   2                      //              Com2SendU8( BMP280RES_C[M2Work.m_hi_tta] );
 198   2                      //      }
 199   2                      //      
 200   2                      //      //Com1SendU8( 0xFe );
 201   2                      //      //Com1SendU8( 0xFe );
 202   2                      //      Com2SendU8( 0xAe );
 203   2                      //}
 204   2      
 205   2                      //M3.m_lightadc = GetADCResult( 0 );
 206   2      
 207   2                      //Com1SendU8is( GET_KEY1, ds1302_table );
 208   2                      //Com1SendU8ss( "," );
 209   2                      //Com1SendU8is( GET_KEYMODE, ds1302_table );
 210   2                      //Com1SendU8ss( "," );
 211   2                      //Com1SendU8is( GET_KEYSWT, ds1302_table );
 212   2                      //Com1SendU8ss( "\n" );
 213   2              }
 214   1      
 215   1      
 216   1              while(1)
 217   1              {
 218   2                      ta3postcmd( &ta3postcmd_state );
 219   2      
 220   2                      ta62readdata( &ta62readdata_state );
 221   2      
 222   2                      tm_tk_n( &ta1comrecv_tm, M5.m_tk_old, M5.m_tk );
 223   2                      tm_tk_n( &ta71beeplong_tm, M5.m_tk_old, M5.m_tk );
 224   2                      M5.m_tk_old = M5.m_tk;
 225   2      
 226   2                      ta71beeplong( &ta71beeplong_state );
 227   2      
 228   2              }
 229   1                       
 230   1      }       
 231          
 232          
 233                  
 234          //
 235          void timer0_routine() interrupt 1  
 236          {
 237   1              //TH0 = ctrl_timer[0];
 238   1              //TL0 = ctrl_timer[1];
 239   1      
 240   1              tta( &tta_state );
 241   1      }
C51 COMPILER V9.00   MAIN                                                                  07/26/2017 18:44:54 PAGE 5   

 242          
 243                  
 244          //
 245          void timer1_routine() interrupt 3  
 246          {
 247   1              ttb( &ttb_state );
 248   1      }
 249          
 250          //
 251          void timer3_routine() interrupt 19  
 252          {
 253   1              ttc( &ttc_state );
 254   1      }
 255          
 256          //
 257          void timer4_routine() interrupt 20  
 258          {
 259   1              //TH0 = g_ctrl_timer[0];
 260   1              //TL0 = g_ctrl_timer[1];
 261   1      
 262   1              ttd( &ttd_state );
 263   1      }
 264          
 265          
 266          
 267                           
 268                            
 269          
 270          /*------------------------------------------------
 271          串口中断程序
 272          ------------------------------------------------*/
 273          void UART_SER() interrupt 4 //串行中断服务程序
 274          {
 275   1              if(RI)      //判断是接收中断产生
 276   1              {
 277   2                      RI=0;     //标志位清零
 278   2      
 279   2                      ta1comrecv( &ta1comrecv_state );
 280   2              }
 281   1      
 282   1              if(TI)    //如果是发送标志位，清零
 283   1              {
 284   2                      TI=0;
 285   2                      Com1_TI_flag = 1; //这样等于发送没做，另找一个flag
 286   2              }
 287   1      }
 288                          
 289          
 290          #define S2RI  0x01              //S2CON.0
 291          #define S2TI  0x02              //S2CON.1
 292          
 293          /*----------------------------
 294          UART2 中断服务程序
 295          -----------------------------*/
 296          void UART2_SER() interrupt 8  
 297          {
 298   1          if (S2CON & S2RI)      //判断是接收中断产生
 299   1          {
 300   2              S2CON &= ~S2RI;         //清除S2RI位
 301   2      
 302   2                      //ta1comrecv( &ta1comrecv_state );
 303   2                      flag2 = 1;
C51 COMPILER V9.00   MAIN                                                                  07/26/2017 18:44:54 PAGE 6   

 304   2          }
 305   1      
 306   1          if (S2CON & S2TI)    //如果是发送标志位，清零
 307   1          {
 308   2              S2CON &= ~S2TI;         //清除S2TI位 
 309   2                      Com2_TI_flag = 1; //这样等于发送没做，另找一个flag
 310   2          }
 311   1                      
 312   1      }
 313          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5143    ----
   CONSTANT SIZE    =    223    ----
   XDATA SIZE       =    430      30
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =      3    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
