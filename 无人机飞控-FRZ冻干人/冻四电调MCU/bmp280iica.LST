C51 COMPILER V9.00   BMP280IICA                                                            07/27/2017 12:08:33 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE BMP280IICA
OBJECT MODULE PLACED IN bmp280iica.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE bmp280iica.c LARGE BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /****** **************/
   2          //#include <reg52.h>
   3          #include "UNIQ_ID.h"
   4          #include "INTRINS.H"
   5          #include "Delay_12M.h"
   6          #include "bmp280iica.h"
   7          
   8          //2017-06-07
   9          
  10          
  11          #define   bool unsigned char
  12          #define   TRUE 1
  13          #define   FALSE 0
  14          #define   u8 unsigned char
  15          #define   uchar unsigned char
  16          #define   uint unsigned int     
  17          #define   u32 unsigned long     
  18          
  19          //  内部地址
  20          //****************************************
  21          //BMP280 I2C address is 0x76(108)
  22          #define BMP280_I2C_ADDRESS   0x76       
  23          
  24          
  25          #define data   BUF      
  26          
  27          
  28          static char BUF[24];       // 数据缓存区   
  29          
  30          
  31          char BMP280_readRC; //读执行正确错误
  32          char   *BMP280RES_C; 
  33           float BMP280_Temperature; 
  34           float BMP280_Pressure; 
  35          
  36          
  37          
  38          
  39          sbit SCL = P2 ^ 0;
  40          sbit SDA = P4 ^ 4;
  41          
  42          // SDI/CSB 接3.3V --影响协议 HIGH=iic
  43          // SDO接地 --影响地址  应该=0,ADDRESS=0x76
  44          
  45          
  46          
  47          
  48          
  49          #define SCL_H         SCL = 1
  50          #define SCL_L         SCL = 0
  51          #define SDA_H         SDA = 1
  52          #define SDA_L         SDA = 0
  53          //#define SCL_read      SCL
  54          #define SDA_read      SDA
  55          
C51 COMPILER V9.00   BMP280IICA                                                            07/27/2017 12:08:33 PAGE 2   

  56          
  57          /*
  58          ********************************************************************************
  59          ** 函数功能 ： 长延时函数       
  60          ******************************************************************************** */
  61          //static void Delayms(u32 m)
  62          //{
  63          //  //u32 i;
  64          //  //
  65          //  //for(; m != 0; m--)        
  66          //  //     for (i=0; i<500; i++);
  67          //
  68          //      DelayMs(m);
  69          //}
  70          
  71          
  72          
  73          /*******************************************************************************
  74          * Function Name  : I2C_delay
  75          * Description    : Simulation IIC Timing series delay
  76          * Input          : None
  77          * Output         : None
  78          * Return         : None
  79          ****************************************************************************** */
  80          static void I2C_delay(void)
  81          {
  82   1         u8 i=93; 
  83   1         while(i) 
  84   1         { 
  85   2           i--; 
  86   2         }  
  87   1      }
  88          
  89          #define delay5us I2C_delay
  90          
  91          
  92          //static void delay5ms(void)
  93          //{
  94          //   //int i=5000;  
  95          //   //while(i) 
  96          //   //{ 
  97          //   //  i--; 
  98          //   //}  
  99          //
 100          //      DelayMs(5);
 101          //}
 102          
 103          
 104          /*******************************************************************************
 105          * Function Name  : I2C_Start
 106          * Description    : Master Start Simulation IIC Communication
 107          * Input          : None
 108          * Output         : None
 109          * Return         : Wheather      Start
 110          ****************************************************************************** */
 111          static bool I2C_Start(void)
 112          {
 113   1              SDA_H;
 114   1              SCL_H;
 115   1              I2C_delay();
 116   1              if(!SDA_read)return FALSE;      //SDA线为低电平则总线忙,退出
 117   1              SDA_L;
C51 COMPILER V9.00   BMP280IICA                                                            07/27/2017 12:08:33 PAGE 3   

 118   1              I2C_delay();
 119   1              if(SDA_read) return FALSE;      //SDA线为高电平则总线出错,退出
 120   1              SDA_L;
 121   1              I2C_delay();
 122   1              return TRUE;
 123   1      }
 124          
 125          /*******************************************************************************
 126          * Function Name  : I2C_Stop
 127          * Description    : Master Stop Simulation IIC Communication
 128          * Input          : None
 129          * Output         : None
 130          * Return         : None
 131          ****************************************************************************** */
 132          static void I2C_Stop(void)
 133          {
 134   1              SCL_L;
 135   1              I2C_delay();
 136   1              SDA_L;
 137   1              I2C_delay();
 138   1              SCL_H;
 139   1              I2C_delay();
 140   1              SDA_H;
 141   1              I2C_delay();
 142   1      } 
 143          
 144          /*******************************************************************************
 145          * Function Name  : I2C_Ack
 146          * Description    : Master Send Acknowledge Single
 147          * Input          : None
 148          * Output         : None
 149          * Return         : None
 150          ****************************************************************************** */
 151          static void I2C_Ack(void)
 152          {       
 153   1              SCL_L;
 154   1              I2C_delay();
 155   1              SDA_L;
 156   1              I2C_delay();
 157   1              SCL_H;
 158   1              I2C_delay();
 159   1              SCL_L;
 160   1              I2C_delay();
 161   1      }  
 162          
 163          /*******************************************************************************
 164          * Function Name  : I2C_NoAck
 165          * Description    : Master Send No Acknowledge Single
 166          * Input          : None
 167          * Output         : None
 168          * Return         : None
 169          ****************************************************************************** */
 170          static void I2C_NoAck(void)
 171          {       
 172   1              SCL_L;
 173   1              I2C_delay();
 174   1              SDA_H;
 175   1              I2C_delay();
 176   1              SCL_H;
 177   1              I2C_delay();
 178   1              SCL_L;
 179   1              I2C_delay();
C51 COMPILER V9.00   BMP280IICA                                                            07/27/2017 12:08:33 PAGE 4   

 180   1      } 
 181          
 182          /*******************************************************************************
 183          * Function Name  : I2C_WaitAck
 184          * Description    : Master Reserive Slave Acknowledge Single
 185          * Input          : None
 186          * Output         : None
 187          * Return         : Wheather      Reserive Slave Acknowledge Single
 188          ****************************************************************************** */
 189          static bool I2C_WaitAck(void)    //返回为:=1有ACK,=0无ACK
 190          {
 191   1              SCL_L;
 192   1              I2C_delay();
 193   1              SDA_H;                  
 194   1              I2C_delay();
 195   1              SCL_H;
 196   1              I2C_delay();
 197   1              if(SDA_read)
 198   1              {
 199   2            SCL_L;
 200   2                I2C_delay();
 201   2            return FALSE;
 202   2              }
 203   1              SCL_L;
 204   1              I2C_delay();
 205   1              return TRUE;
 206   1      }
 207          
 208          /*******************************************************************************
 209          * Function Name  : I2C_SendByte
 210          * Description    : Master Send a Byte to Slave
 211          * Input          : Will Send Date
 212          * Output         : None
 213          * Return         : None
 214          ****************************************************************************** */
 215          static void I2C_SendByte(u8 SendByte) //数据从高位到低位//
 216          {
 217   1          u8 i=8;
 218   1          while(i--)
 219   1          {
 220   2              SCL_L;
 221   2              I2C_delay();
 222   2            if(SendByte&0x80)
 223   2              SDA_H;  
 224   2            else 
 225   2              SDA_L;   
 226   2              SendByte<<=1;
 227   2              I2C_delay();
 228   2                      SCL_H;
 229   2              I2C_delay();
 230   2          }
 231   1          SCL_L;
 232   1      }  
 233          
 234          /*******************************************************************************
 235          * Function Name  : I2C_ReadByte
 236          * Description    : Master Reserive a Byte From Slave
 237          * Input          : None
 238          * Output         : None
 239          * Return         : Date From Slave 
 240          ****************************************************************************** */
 241          static unsigned char I2C_ReadByte(void)  //数据从高位到低位//
C51 COMPILER V9.00   BMP280IICA                                                            07/27/2017 12:08:33 PAGE 5   

 242          { 
 243   1          u8 i=8;
 244   1          u8 ReceiveByte=0;
 245   1      
 246   1          SDA_H;                              
 247   1          while(i--)
 248   1          {
 249   2            ReceiveByte<<=1;      
 250   2            SCL_L;
 251   2            I2C_delay();
 252   2                SCL_H;
 253   2            I2C_delay();      
 254   2            if(SDA_read)
 255   2            {
 256   3              ReceiveByte|=0x01;
 257   3            }
 258   2          }
 259   1          SCL_L;
 260   1          return ReceiveByte;
 261   1      } 
 262          
 263          //           
 264          //单字节写入*******************************************
 265          static bool Single_Write(unsigned char SlaveAddress,unsigned char REG_Address,unsigned char REG_data)    
 266          {
 267   1              if(!I2C_Start()) return FALSE;
 268   1          I2C_SendByte( SlaveAddress * 2 ); 
 269   1          if(!I2C_WaitAck())
 270   1              {
 271   2                      //I2C_Stop();
 272   2                      //return FALSE;
 273   2              }
 274   1      
 275   1          I2C_SendByte( REG_Address);      
 276   1          I2C_WaitAck();
 277   1      
 278   1          I2C_SendByte(REG_data);
 279   1          I2C_WaitAck(); 
 280   1      
 281   1          I2C_Stop(); 
 282   1          
 283   1          return TRUE;
 284   1      }
 285          
 286          
 287          // 读取*****************************************
 288          static bool Many_Read(unsigned char SlaveAddress, unsigned char REG_Address, unsigned char ret_len )
 289          { 
 290   1              unsigned char i;
 291   1      
 292   1              if(!I2C_Start()) return BMP280_readRC = FALSE;
 293   1          I2C_SendByte( SlaveAddress * 2 ); 
 294   1          if(!I2C_WaitAck())
 295   1              {
 296   2                      //I2C_Stop();
 297   2                      //return BMP280_readRC = FALSE;
 298   2              }
 299   1      
 300   1          I2C_SendByte( REG_Address);      
 301   1          I2C_WaitAck();
 302   1      
 303   1          I2C_Start();
C51 COMPILER V9.00   BMP280IICA                                                            07/27/2017 12:08:33 PAGE 6   

 304   1          I2C_SendByte( SlaveAddress * 2 + 1 );
 305   1          I2C_WaitAck();
 306   1      
 307   1              for( i = 0; i < ret_len ; i++ )
 308   1              {
 309   2                      BUF[i] = I2C_ReadByte();
 310   2                      if( i != ret_len - 1 ) I2C_Ack();
 311   2              }
 312   1      
 313   1          I2C_NoAck();
 314   1          I2C_Stop();
 315   1          return BMP280_readRC = TRUE;
 316   1      }                                                     
 317          
 318          
 319          #define   double float
 320          
 321          static uint dig_T1;
 322          static int dig_T2;
 323          static int dig_T3;
 324          static uint dig_P1;
 325          static int dig_P2;
 326          static int dig_P3;
 327          static int dig_P4;
 328          static int dig_P5;
 329          static int dig_P6;
 330          static int dig_P7;
 331          static int dig_P8;
 332          static int dig_P9;
 333          
 334          
 335          
 336          void Reset_BMP280( void )
 337          {
 338   1              BMP280RES_C = BUF;
 339   1      
 340   1      
 341   1              //Single_Write( BMP280_I2C_ADDRESS, 0xe0, 0xb6 );
 342   1              //DelayMs(999);
 343   1      
 344   1      
 345   1              // Read 24 bytes of data from address(0x88)
 346   1              Many_Read( BMP280_I2C_ADDRESS, 0x88 , 24 ); 
 347   1              if( BMP280_readRC == FALSE ) return;
 348   1            I2C_delay();
 349   1            I2C_delay();
 350   1              DelayMs(10);
 351   1              
 352   1      
 353   1              dig_T1 = data[1] * 256 + data[0];
 354   1              dig_T2 = data[3] * 256 + data[2];
 355   1              dig_T3 = data[5] * 256 + data[4];
 356   1              dig_P1 = data[7] * 256 + data[6];
 357   1              dig_P2 = data[9] * 256 + data[8];
 358   1              dig_P3 = data[11]* 256 + data[10];
 359   1              dig_P4 = data[13]* 256 + data[12];
 360   1              dig_P5 = data[15]* 256 + data[14];
 361   1              dig_P6 = data[17]* 256 + data[16];
 362   1              dig_P7 = data[19]* 256 + data[18];
 363   1              dig_P8 = data[21]* 256 + data[20];
 364   1              dig_P9 = data[23]* 256 + data[22];
 365   1      
C51 COMPILER V9.00   BMP280IICA                                                            07/27/2017 12:08:33 PAGE 7   

 366   1              // Select control measurement register(0xF4)
 367   1              // Normal mode, temp and pressure over sampling rate = 1(0x27)
 368   1              Single_Write( BMP280_I2C_ADDRESS, 0xF4, 0x27 );
 369   1              DelayMs(10);
 370   1      
 371   1              // Select config register(0xF5)
 372   1              // Stand_by time = 1000 ms(0xA0)
 373   1              Single_Write( BMP280_I2C_ADDRESS, 0xF5, 0xA0 );
 374   1              DelayMs(10);
 375   1      
 376   1      }
 377          
 378                   
 379          
 380          
 381          // *******************
 382          void Get_BMP280(void)
 383          {
 384   1       long adc_p;
 385   1       long adc_t;
 386   1       double var1;
 387   1       double var2;
 388   1       double t_fine;
 389   1       double cTemp;
 390   1              double p;
 391   1      
 392   1              BMP280RES_C = BUF;
 393   1      
 394   1              //// Read 24 bytes of data from address(0x88)
 395   1              //Many_Read( BMP280_I2C_ADDRESS, 0x88 , 24 ); 
 396   1              //if( BMP280_readRC == FALSE ) return;
 397   1       //     I2C_delay();
 398   1       //     I2C_delay();
 399   1              //DelayMs(10);
 400   1              //
 401   1      
 402   1              //dig_T1 = data[1] * 256 + data[0];
 403   1              //dig_T2 = data[3] * 256 + data[2];
 404   1              //dig_T3 = data[5] * 256 + data[4];
 405   1              //dig_P1 = data[7] * 256 + data[6];
 406   1              //dig_P2 = data[9] * 256 + data[8];
 407   1              //dig_P3 = data[11]* 256 + data[10];
 408   1              //dig_P4 = data[13]* 256 + data[12];
 409   1              //dig_P5 = data[15]* 256 + data[14];
 410   1              //dig_P6 = data[17]* 256 + data[16];
 411   1              //dig_P7 = data[19]* 256 + data[18];
 412   1              //dig_P8 = data[21]* 256 + data[20];
 413   1              //dig_P9 = data[23]* 256 + data[22];
 414   1      
 415   1              //// Select control measurement register(0xF4)
 416   1              //// Normal mode, temp and pressure over sampling rate = 1(0x27)
 417   1              //Single_Write( BMP280_I2C_ADDRESS, 0xF4, 0x27 );
 418   1              //DelayMs(10);
 419   1      
 420   1              //// Select config register(0xF5)
 421   1              //// Stand_by time = 1000 ms(0xA0)
 422   1              //Single_Write( BMP280_I2C_ADDRESS, 0xF5, 0xA0 );
 423   1              //DelayMs(10);
 424   1      
 425   1              
 426   1              // Read from register(0xF7)
 427   1              Many_Read( BMP280_I2C_ADDRESS, 0xF7 , 6 ); 
C51 COMPILER V9.00   BMP280IICA                                                            07/27/2017 12:08:33 PAGE 8   

 428   1              //DelayMs(10);
 429   1      
 430   1              // Convert pressure and temperature data to 19-bits
 431   1               adc_p = (((long)data[0] * 65536L) + ((long)data[1] * 256L) + (long)(data[2] & 0xF0)) / 16;
 432   1               adc_t = (((long)data[3] * 65536L) + ((long)data[4] * 256L) + (long)(data[5] & 0xF0)) / 16;
 433   1               //int adc_T = ((tmp_buff[0]<<16)|(tmp_buff[1]<<8)|(tmp_buff[2]))>>4; 
 434   1               //adc_t =      ( ( (long)(data[3]) ) << 16 ) | 
 435   1                      //                      ( ( (long)(data[4]) ) <<  8 ) | 
 436   1                      //                        ( data[5] & 0xF0  )    ; 
 437   1               //adc_t /= 16; 
 438   1                      
 439   1               // Temperature offset calculations
 440   1               var1 = (((double)adc_t) / 16384.0 - ((double)dig_T1) / 1024.0) * ((double)dig_T2);
 441   1               var2 = ((((double)adc_t) / 131072.0 - ((double)dig_T1) / 8192.0) *(((double)adc_t)/131072.0 - ((double)d
             -ig_T1)/8192.0)) * ((double)dig_T3);
 442   1               t_fine = (long)(var1 + var2);
 443   1               cTemp = (var1 + var2) / 5120.0;
 444   1               BMP280_Temperature = cTemp * 1.8 + 32;
 445   1      
 446   1               // Pressure offset calculations
 447   1              var1 = ((double)t_fine / 2.0) - 64000.0;
 448   1              var2 = var1 * var1 * ((double)dig_P6) / 32768.0;
 449   1              var2 = var2 + var1 * ((double)dig_P5) * 2.0;
 450   1              var2 = (var2 / 4.0) + (((double)dig_P4) * 65536.0);
 451   1              var1 = (((double) dig_P3) * var1 * var1 / 524288.0 + ((double) dig_P2) * var1) / 524288.0;
 452   1              var1 = (1.0 + var1 / 32768.0) * ((double)dig_P1);
 453   1               p = 1048576.0 - (double)adc_p;
 454   1              p = (p - (var2 / 4096.0)) * 6250.0 / var1;
 455   1              var1 = ((double) dig_P9) * p * p / 2147483648.0;
 456   1              var2 = p * ((double) dig_P8) / 32768.0;
 457   1               BMP280_Pressure = (p + (var1 + var2 + ((double)dig_P7)) / 16.0) ; 
 458   1      
 459   1      }
 460          
 461          
 462          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2219    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     60      28
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
