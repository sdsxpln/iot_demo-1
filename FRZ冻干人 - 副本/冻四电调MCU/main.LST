C51 COMPILER V9.00   MAIN                                                                  07/27/2017 12:08:32 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c LARGE BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /*******************/
   2          //#include <reg52.h>
   3          #include "STDIO.H"
   4          #include "STDLIB.H"
   5          #include "INTRINS.H"
   6          #include "STRING.H"
   7          #include "Delay_12M.h"
   8          #include "UNIQ_ID.h"
   9          #include "a_strfunc.h"
  10          #include "a_comfunc.h"
  11          #include "a_timerfunc.h"
  12          //#include "lcd_12864.h"
  13          #include "mainioport.h"
  14          #include "EEPROM.h"
  15          #include "stc12_adc.h"
  16          #include "a_ll1func.h"
  17          //#include "ds1302.h"
  18          #include "mpu9250iica.h"
  19          #include "bmp180.h"
  20          #include "bmp280iica.h"
  21          
  22          
  23          unsigned char idata g_ctrl_timer[2];
  24          unsigned int idata * idata g_p_ctrl_timer;
  25          
  26          
  27          #define    FIRMWAREVER   "V1.00"
  28          
  29          
  30          #define S1_S0 0x40              //P_SW1.6
  31          #define S1_S1 0x80              //P_SW1.7
  32          
  33          #define S2_S0 0x01              //P_SW2.0
  34          
  35          
  36          #include "main1.xpp"
  37          #include "main2.xpp"
  38          
  39          
  40          
  41          
  42          void Timer0Init(void)           //5毫秒@24.000MHz
  43          {
  44   1              AUXR &= 0x7F;           //定时器时钟12T模式
  45   1              TMOD &= 0xF0;           //设置定时器模式
  46   1              TL0 = 0xF0;             //设置定时初值
  47   1              TH0 = 0xD8;             //设置定时初值
  48   1              TF0 = 0;                //清除TF0标志
  49   1              TR0 = 1;                //定时器0开始计时
  50   1      }
  51          
  52          void Timer1Init(void)           //5毫秒@24.000MHz
  53          {
  54   1              AUXR &= 0xBF;           //定时器时钟12T模式
  55   1              TMOD &= 0x0F;           //设置定时器模式
C51 COMPILER V9.00   MAIN                                                                  07/27/2017 12:08:32 PAGE 2   

  56   1              TL1 = 0xF0;             //设置定时初值
  57   1              TH1 = 0xD8;             //设置定时初值
  58   1              TF1 = 0;                //清除TF1标志
  59   1              TR1 = 1;                //定时器1开始计时
  60   1      }
  61          
  62          void Timer3Init(void)           //5毫秒@24.000MHz
  63          {
  64   1              T4T3M &= 0xFD;          //定时器时钟12T模式
  65   1              T3L = 0xF0;             //设置定时初值
  66   1              T3H = 0xD8;             //设置定时初值
  67   1              T4T3M |= 0x08;          //定时器3开始计时
  68   1      }
  69          
  70          void Timer4Init(void)           //5毫秒@24.000MHz
  71          {
  72   1              T4T3M &= 0xDF;          //定时器时钟12T模式
  73   1              T4L = 0xF0;             //设置定时初值
  74   1              T4H = 0xD8;             //设置定时初值
  75   1              T4T3M |= 0x80;          //定时器4开始计时
  76   1      }
  77          
  78          
  79          
  80          // 使用定时器2
  81          void Uart1Init(void)            //9600bps@24.000MHz
  82          {
  83   1              SCON = 0x50;            //8位数据,可变波特率
  84   1              AUXR |= 0x01;           //串口1选择定时器2为波特率发生器
  85   1              AUXR &= 0xFB;           //定时器2时钟为Fosc/12,即12T
  86   1              T2L = 0xCC;             //设定定时初值
  87   1              T2H = 0xFF;             //设定定时初值
  88   1              AUXR |= 0x10;           //启动定时器2
  89   1      }
  90          
  91          void Uart2Init(void)            //9600bps@24.000MHz
  92          {
  93   1              S2CON = 0x50;           //8位数据,可变波特率
  94   1              AUXR &= 0xFB;           //定时器2时钟为Fosc/12,即12T
  95   1              T2L = 0xCC;             //设定定时初值
  96   1              T2H = 0xFF;             //设定定时初值
  97   1              AUXR |= 0x10;           //启动定时器2
  98   1      }
  99          
 100          
 101          char flag2;
 102          
 103          
 104          //
 105          //主函数 入口函数:
 106          void main()
 107          {
 108   1              g_p_ctrl_timer = (unsigned int*)g_ctrl_timer;
 109   1              *g_p_ctrl_timer = 65535L - 59999;
 110   1              
 111   1              //初始化
 112   1              EA=0;           // 总中断
 113   1       
 114   1              Timer0Init();
 115   1              Timer1Init();
 116   1              Timer3Init();
 117   1              Timer4Init();
C51 COMPILER V9.00   MAIN                                                                  07/27/2017 12:08:32 PAGE 3   

 118   1              ET0=1;          //开启定时器0中断
 119   1              ET1 = 1;                        //使能定时器
 120   1              //IE2 |= 0x04;                    //开定时器2中断
 121   1              IE2 |= 0x20;                    //开定时器3中断
 122   1              IE2 |= 0x40;                    //开定时器4中断
 123   1      
 124   1      
 125   1              Uart1Init();
 126   1        //ACC = P_SW1;
 127   1        //ACC &= ~(S1_S0 | S1_S1);    //S1_S0=1 S1_S1=0
 128   1        //ACC |= S1_S0;               //(P3.6/RxD_2, P3.7/TxD_2)
 129   1        //P_SW1 = ACC;  
 130   1              ES = 1;                     //使能串口中断
 131   1      
 132   1              Uart2Init();
 133   1        P_SW2 |= S2_S0;             //S2_S0=1 (P4.6/RxD2_2, P4.7/TxD2_2)
 134   1              IE2 = 0x01;                 //使能串口2中断
 135   1              
 136   1              //切换优先级
 137   1              //PT0 = 0;
 138   1              //PS = 1;
 139   1              //IP2 |= 1;
 140   1      
 141   1      
 142   1              //Com2SendU8ss( "AT+BOUD3" );应该在使能之后再发出。
 143   1              //DelayMs(300);
 144   1      
 145   1      
 146   1              //用户初始化 
 147   1              mainioport_init();
 148   1      
 149   1              M1Conf_t_default( &M1 );
 150   1              M5Runtime_t_default( &M5 );
 151   1              M12Pwm_t_default( M12 + 0 );
 152   1              M12Pwm_t_default( M12 + 1 );
 153   1              M12Pwm_t_default( M12 + 2 );
 154   1              M12Pwm_t_default( M12 + 3 );
 155   1              M22ATbuf_t_default( M22 + 0 );
 156   1              M22ATbuf_t_default( M22 + 1 );
 157   1              
 158   1              Init_MPU9250();
 159   1              Init_BMP085();
 160   1              //Reset_BMP280();
 161   1      
 162   1              tm_init( &ta1comrecv_tm );
 163   1              tm_init( &ta71beeplong_tm );
 164   1              tm_init( &ta72beepshort_tm );
 165   1      
 166   1              LET_BEEP1_OFF;
 167   1              LET_LED1_OFF;
 168   1              LET_LED2_OFF;
 169   1      
 170   1              DelayMs(300);
 171   1              EA  = 1;          //打开总中断 
 172   1      
 173   1                
 174   1      
 175   1              while(EA)
 176   1              {
 177   2                       
 178   2                      DelayMs(333);
 179   2              
C51 COMPILER V9.00   MAIN                                                                  07/27/2017 12:08:32 PAGE 4   

 180   2                      //M2Work.m_hi_tta = 900;
 181   2                      //M2Work.m_hi_ttb = 900;
 182   2                      //M2Work.m_hi_ttc = 900;
 183   2                      //M2Work.m_hi_ttd = 900;
 184   2      
 185   2                      //sharedata_main_ready( &M2[0] , &M2[1] , &M2[2] , sizeof( struct M12Pwm_t ) );
 186   2                      
 187   2                      Get_BMP280();
 188   2      
 189   2                      sprintf( printbuf, "%f, %f\r\n", BMP280_Pressure, BMP280_Temperature );
 190   2                      //              sprintf( printbuf, "OK. %ld,%ld\r\n",   g_bmp085_pressure, g_bmp085_temperature );
 191   2                      Com1SendU8ss( printbuf );
 192   2      
 193   2                      READ_MPU9250_ACCEL();
 194   2                      sprintf( printbuf, "%f, %f,%f\r\n", MPU9250RES_F[0], MPU9250RES_F[1], MPU9250RES_F[2] );
 195   2                      Com1SendU8ss( printbuf );
 196   2      
 197   2                      //READ_MPU9250_GYRO();
 198   2                      //READ_MPU9250_MAG();
 199   2      
 200   2                      //if( flag2 )
 201   2                      //{
 202   2                      //      flag2 = 0;
 203   2      
 204   2                      //      for( M2Work.m_hi_tta = 0; M2Work.m_hi_tta < 24; M2Work.m_hi_tta++ )
 205   2                      //      {
 206   2                      //              Com2SendU8( BMP280RES_C[M2Work.m_hi_tta] );
 207   2                      //      }
 208   2                      //      
 209   2                      //      //Com1SendU8( 0xFe );
 210   2                      //      //Com1SendU8( 0xFe );
 211   2                      //      Com2SendU8( 0xAe );
 212   2                      //}
 213   2      
 214   2                      //M3.m_lightadc = GetADCResult( 0 );
 215   2      
 216   2                      //Com1SendU8is( GET_KEY1, ds1302_table );
 217   2                      //Com1SendU8ss( "," );
 218   2                      //Com1SendU8is( GET_KEYMODE, ds1302_table );
 219   2                      //Com1SendU8ss( "," );
 220   2                      //Com1SendU8is( GET_KEYSWT, ds1302_table );
 221   2                      //Com1SendU8ss( "\n" );
 222   2              }
 223   1      
 224   1      
 225   1              M5.m_beepshort = 1;
 226   1      
 227   1              while(1)
 228   1              {
 229   2                      ta3postcmd( &ta3postcmd_state );
 230   2      
 231   2                      ta62readdata( &ta62readdata_state );
 232   2      
 233   2                      tm_tk_n( &ta1comrecv_tm, M5.m_tk_old, M5.m_tk );
 234   2                      tm_tk_n( &ta71beeplong_tm, M5.m_tk_old, M5.m_tk );
 235   2                      tm_tk_n( &ta72beepshort_tm, M5.m_tk_old, M5.m_tk );
 236   2                      M5.m_tk_old = M5.m_tk;
 237   2      
 238   2                      ta71beeplong( &ta71beeplong_state );
 239   2                      ta72beepshort( &ta72beepshort_state );
 240   2      
 241   2              }
C51 COMPILER V9.00   MAIN                                                                  07/27/2017 12:08:32 PAGE 5   

 242   1                       
 243   1      }       
 244          
 245          
 246                  
 247          //
 248          void timer0_routine() interrupt 1  
 249          {
 250   1              //TH0 = ctrl_timer[0];
 251   1              //TL0 = ctrl_timer[1];
 252   1      
 253   1              tta( &tta_state );
 254   1      }
 255          
 256                  
 257          //
 258          void timer1_routine() interrupt 3  
 259          {
 260   1              ttb( &ttb_state );
 261   1      }
 262          
 263          //
 264          void timer3_routine() interrupt 19  
 265          {
 266   1              ttc( &ttc_state );
 267   1      }
 268          
 269          //
 270          void timer4_routine() interrupt 20  
 271          {
 272   1              //TH0 = g_ctrl_timer[0];
 273   1              //TL0 = g_ctrl_timer[1];
 274   1      
 275   1              ttd( &ttd_state );
 276   1      }
 277          
 278          
 279          
 280                           
 281                            
 282          
 283          /*------------------------------------------------
 284          串口中断程序
 285          ------------------------------------------------*/
 286          void UART_SER() interrupt 4 //串行中断服务程序
 287          {
 288   1              if(RI)      //判断是接收中断产生
 289   1              {
 290   2                      RI=0;     //标志位清零
 291   2      
 292   2                      ta1comrecv( &ta1comrecv_state );
 293   2              }
 294   1      
 295   1              if(TI)    //如果是发送标志位，清零
 296   1              {
 297   2                      TI=0;
 298   2                      Com1_TI_flag = 1; //这样等于发送没做，另找一个flag
 299   2              }
 300   1      }
 301                          
 302          
 303          #define S2RI  0x01              //S2CON.0
C51 COMPILER V9.00   MAIN                                                                  07/27/2017 12:08:32 PAGE 6   

 304          #define S2TI  0x02              //S2CON.1
 305          
 306          /*----------------------------
 307          UART2 中断服务程序
 308          -----------------------------*/
 309          void UART2_SER() interrupt 8  
 310          {
 311   1          if (S2CON & S2RI)      //判断是接收中断产生
 312   1          {
 313   2              S2CON &= ~S2RI;         //清除S2RI位
 314   2      
 315   2                      //ta1comrecv( &ta1comrecv_state );
 316   2                      flag2 = 1;
 317   2          }
 318   1      
 319   1          if (S2CON & S2TI)    //如果是发送标志位，清零
 320   1          {
 321   2              S2CON &= ~S2TI;         //清除S2TI位 
 322   2                      Com2_TI_flag = 1; //这样等于发送没做，另找一个flag
 323   2          }
 324   1                      
 325   1      }
 326          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5611    ----
   CONSTANT SIZE    =    244    ----
   XDATA SIZE       =    459      36
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =      3    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
