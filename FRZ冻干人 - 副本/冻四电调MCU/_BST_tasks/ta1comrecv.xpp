//
// com 的接收任务	
//AT+<para>,<para>|<chk>;
int ta1comrecv_state = 0; 
U8  ta1comrecv_1stgetinput_flag = 0;
U8  ta1comrecv_tempc;
U8  ta1comrecv_bufidx;
U8 *ta1comrecv_bufp;
U8 code ta1comrecv_bufMax = 40;
struct TM_t ta1comrecv_tm;
#define  ta1comrecv_MYSBUF    SBUF    /* 串口数据 */
#if	 0
//#THREADBEGIN#
void ta1comrecv( int *pstate )
{
	//#FUNCBEGIN#
	while(1)
	{
		 
LLL_10:;  // _LL_AT命令之前
		if( ta1comrecv_1stgetinput_flag == 0 ) //首次,get input
		{
			ta1comrecv_1stgetinput_flag++;
		}
		else
		{
			##DELAY#
		}
		ta1comrecv_tempc = ta1comrecv_MYSBUF;
LLL_5:;  // _LL_AT命令之前由于超时造成
		
		if( ta1comrecv_tempc == 'A' )
		{
			//flow down
		}
		else
		{
			goto LLL_10; // to LL_LL_AT命令之前
		}
		##DELAY#
		ta1comrecv_tempc = ta1comrecv_MYSBUF;
		if( ta1comrecv_tempc == 'T' )
		{
			//flow down
		}
		else
		{
			goto LLL_10; // to LL_LL_AT命令之前
		}
//LL_LL_AT命数块开始前:;
//LL_LL_AT命数块准备:;
		//准备活动	
		ta1comrecv_bufp = M22[0].m_buf; 
		ta1comrecv_bufidx = 0;
		ta1comrecv_bufp[ta1comrecv_bufidx] = 0;
LLL_8:; // _LL_AT命数块继续接收
		tm_rst( &ta1comrecv_tm, 7 ); 
	
		// 超时
		// 超长	
		// %	
		// ;  分号	
		// 常规字符		
		##DELAY#
		ta1comrecv_tempc = ta1comrecv_MYSBUF;
		
		// 超时
		if( ta1comrecv_tm.overflow_flag )
		{
			goto LLL_5; // to LL_LL_AT命令之前由于超时造成
		}
	
		// len超长	
		if( ta1comrecv_bufidx >= ta1comrecv_bufMax )
		{
			goto LLL_10; // to LL_LL_AT命令之前
		}
		// 分号;	
		if( ta1comrecv_tempc == ';' )
		{
			goto LLL_9; // to LL_LL_AT命令帧结束备解析
		}
		// 常规字符		
		if(1)
		{
			ta1comrecv_bufp[ta1comrecv_bufidx] = ta1comrecv_tempc;
			ta1comrecv_bufidx++;
			ta1comrecv_bufp[ta1comrecv_bufidx] = 0;
			
			goto LLL_8; // to LL_LL_AT命数块继续接收
		}
	 
LLL_9:; // _LL_AT命令帧结束备解析
		//此时 得到了一帧原始有%的AT之后的无分号的数据块
		if( M22[0].m_busy_flag == 0 )
		{
			memcpy( &(M22[1]) , &(M22[0]) , sizeof( struct M22ATbuf_t ) );
			ll1_reset( M22[1].m_buf, ta1comrecv_bufidx );
			M22[0].m_busy_flag = 1;
		}
	
		goto LLL_10; // to LL_LL_AT命令之前
	}
	//#FUNCEND#
}
//#THREADEND#
#endif


/*======== donnot modify the generated code below manually =========*/ 

//#THREADBEGIN#
void ta1comrecv( int *pstate )
{
	//#FUNCBEGIN#
	switch (*pstate) { 
	case 1 : goto LL_1; 
	case 2 : goto LL_2; 
	case 3 : goto LL_3; 
	default: break; 
	} 

	while(1)
	{
		 
LLL_10:;  // _LL_AT命令之前
		if( ta1comrecv_1stgetinput_flag == 0 ) //首次,get input
		{
			ta1comrecv_1stgetinput_flag++;
		}
		else
		{
			*pstate = 1;
			return;
			LL_1:;
		}
		ta1comrecv_tempc = ta1comrecv_MYSBUF;
LLL_5:;  // _LL_AT命令之前由于超时造成
		
		if( ta1comrecv_tempc == 'A' )
		{
			//flow down
		}
		else
		{
			goto LLL_10; // to LL_LL_AT命令之前
		}
		*pstate = 2;
		return;
		LL_2:;
		ta1comrecv_tempc = ta1comrecv_MYSBUF;
		if( ta1comrecv_tempc == 'T' )
		{
			//flow down
		}
		else
		{
			goto LLL_10; // to LL_LL_AT命令之前
		}
//LL_LL_AT命数块开始前:;
//LL_LL_AT命数块准备:;
		//准备活动	
		ta1comrecv_bufp = M22[0].m_buf; 
		ta1comrecv_bufidx = 0;
		ta1comrecv_bufp[ta1comrecv_bufidx] = 0;
LLL_8:; // _LL_AT命数块继续接收
		tm_rst( &ta1comrecv_tm, 7 ); 
	
		// 超时
		// 超长	
		// %	
		// ;  分号	
		// 常规字符		
		*pstate = 3;
		return;
		LL_3:;
		ta1comrecv_tempc = ta1comrecv_MYSBUF;
		
		// 超时
		if( ta1comrecv_tm.overflow_flag )
		{
			goto LLL_5; // to LL_LL_AT命令之前由于超时造成
		}
	
		// len超长	
		if( ta1comrecv_bufidx >= ta1comrecv_bufMax )
		{
			goto LLL_10; // to LL_LL_AT命令之前
		}
		// 分号;	
		if( ta1comrecv_tempc == ';' )
		{
			goto LLL_9; // to LL_LL_AT命令帧结束备解析
		}
		// 常规字符		
		if(1)
		{
			ta1comrecv_bufp[ta1comrecv_bufidx] = ta1comrecv_tempc;
			ta1comrecv_bufidx++;
			ta1comrecv_bufp[ta1comrecv_bufidx] = 0;
			
			goto LLL_8; // to LL_LL_AT命数块继续接收
		}
	 
LLL_9:; // _LL_AT命令帧结束备解析
		//此时 得到了一帧原始有%的AT之后的无分号的数据块
		if( M22[0].m_busy_flag == 0 )
		{
			memcpy( &(M22[1]) , &(M22[0]) , sizeof( struct M22ATbuf_t ) );
			ll1_reset( M22[1].m_buf, ta1comrecv_bufidx );
			M22[0].m_busy_flag = 1;
		}
	
		goto LLL_10; // to LL_LL_AT命令之前
	}
	//#FUNCEND#
}
//#THREADEND#


